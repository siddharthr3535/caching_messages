How this program works : 

Message Class Contains:
1. ID
2. Content
3. Sender
4. Receiver
5. Timestamp
6. Delivered 

CacheStorage
Represents a single node in the caches doublylinked list.
 Contains: Message instance, previous pointer, next pointer
 Used to maintain cache ordering for replacement algorithms

Cache
 Implements LRU caching with configurable replacement strategies
 Uses HashMap for O(1) message lookup by ID
 Uses doublylinked list with dummy head/tail nodes for efficient insertion/deletion
 Tracks cache hits and misses for performance evaluation
 Supports three replacement strategies: LRU, LIFO, Random.

 MessageStorage
 Handles disk I/O operations 
 Creates binary files in messages directory
 Integrates with Cache for readthrough caching

  HashMap: Stores <MessageID, CacheStorage> pairs for O(1) lookup
 DoublyLinked List: Maintains message order for replacement algorithms
   Dummy head and tail nodes simplify insertion/deletion operations

How the Caching is Implemented:
1. When a message is sent or received, it is added to the cache using the add method.
   I have used a HashMap to store messages with their ID as the key for quick access.
   It is in the form of a custom double linked list to maintain the order of messages.

To implement LRU (Least Recently Used) caching, whenever a message is accessed (added or retrieved), 
it is moved to the front of the linked list. If the cache exceeds its maximum size, the least recently 
used message (at the end of the list) is removed. This ensures that the most recently used messages 
are always at the front, and the least recently used ones are evicted first.

To implement LIFO (Last In, First Out) caching, the Message node at the end of the linked list is removed
when the cache exceeds its maximum size. 

To implement Random deletion, the IDs of the messages are stored in an array, and a random ID is selected
using the Random class in java. This ensures that the index of the array is always random. 

To enforce message size, there is a properties file that specifies the maximum size of messages allowed in the cache.
In the Message constructor, a check is performed to ensure that the content size does not exceed this limit.

To ensure that this configuration is flexible, the properties file can be modified without changing the codebase.
The static block in the Config class loads the properties file at runtime, allowing for easy adjustments to cache settings.



    